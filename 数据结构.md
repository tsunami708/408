# ==复杂度==

> [!NOTE]
> 数据对象由相同性质的数据元素组成，数据元素由数据项组成
> DS三要素：逻辑结构(独立)，存储结构，运算
> 

> [!NOTE] 时间复杂度
> 最坏情况作为评价标准
> 
> 迭代: 统计循环主题频度之和，设某条语句执行次数为t方程求解
> 	嵌套循环由内向外
> 
> 递归: 列出T(n)递推式
```
*1.2.3*
[迭代]
6, 7, 8, 9, 10, 12, 14, 15, 16, 17, 18
[递归]
11, 13, 斐波那契数列思考题 
```
# ==线性表==
# ==栈-队列-数组==

## 栈
- **基本性质与运算**
```
*3.1.4*
1, 2, 3, 4, 6, 8, 9, 10, 11, 24, 25, 31

*3.3.6*
17, 11, 1
```

> [!NOTE] 
> 共享栈(降低上溢可能)
> 上溢～满写
> 下溢～空读

- **出栈入栈模拟**
```
*3.1.4*
7, 12, 16, 26, 30, 27, 
```
- **确定某一个出栈元素**
```
*3.1.4*
17, 18, 20, 21, 22, 29,
```
- **某子列为前缀的出栈序列**
```
*3.1.4*
15, 28, 
```
- **非法出栈序列**
```
*3.1.4*
14, 19,
```

> [!NOTE] 
> 某一个元素出栈时，在其之前入栈的元素若未出栈，则将来必定逆序输出，基于此规律可以快速排出非法序列
> 该规律也可以用于解决前缀出栈序列和某一个出栈元素

- **出栈序列数**
$$
卡特兰数 \frac{1}{n+1} C\genfrac{}{}{0pt}{}{n}{2n}
$$
```
*3.1.4*
13, 23, 
```
- 应用
```
*3.3.6*
表达式运算 2, 4, 13, 14, 19, 18
递归 5, 6, 7, 8, 15
括号匹配 20
```
> [!NOTE] 
> 中缀转后缀括号处理：
> ***操作数直接入结果，操作符优先级高于栈顶则入栈，否则出栈，直至栈空或遇到优先级更低的算符 或 ( 最后在入栈***
> 括号也视作操作符
> **右括号优先级最低**
> **左括号优先级入栈前最高，入栈后最低**

## 队列
- 基本特性与运算
```
*3.2.5*
1, 2, 3, 11, 12, 13, 14, 15, 16, 17

*3.3.6*
3, 10, 12
```
- 出队序列
```
*3.2.5*
4, 18, 23, 24, 

6, 8, 9. 10 [空满判断]

*3.3.6*
16 [多队列出入队]
```
- 循环队列
```
*3.2.5*
5, 7, 21

```

> [!NOTE]
> front指向队首，rear指向队尾下一位
> front指向队首下一位，rear指向队尾
> 二者在判空满运算是等价的
> **空:rear\==front**
> **满:(rear+1)%n\==front**
> **长度:(rear-front+n)%n**

- 双端队列
```
*3.2.5*
19, 20, 22
```
## 特殊矩阵
- 数组
```
*3.4.5*
4, 5, 15
```
- 对称矩阵
```
*3.4.5*
2, 3, 13, 14
```
- 三对角矩阵
```
*3.4.5*
6, 11 
```
- 三角矩阵
```
*3.4.5*
7, 8, 
```
- 稀疏矩阵
```
*3.4.5*
9, 12, 16
```
# ==树==

> [!NOTE] 
> 结点数 = 边数+1 = 度和+1
> 森林中的每一棵树结点数比边数多1

- 结点数~度数~边数~高度
$$
\begin{bmatrix}
nn_n+...+2n_2+n_1=M \\
n_n+...n_0=M+1
\end{bmatrix}
$$
```
*5.1.3*
2, 7, 8, 9, 10, 4, 5, 6
*5.2.3*
23, 19, 29
	[二叉树]
	*5.2.3*
	4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 22, 24, 25, 26, 27, 
```

> [!NOTE] 
> 对于求h的最小值，通过建立前h-1层和前h层与n的不等式求解
- 二叉树种数
```
*5.2.3*
6, 
```
- 完全二叉树与满二叉树的性质
```
*5.2.3*
20, 21
```
- 二叉树存储
```
*5,2,3*
28, 30
```
# ==图==
# ==查找==
# ==排序==