# 复杂度
- 数据结构
	**数据对象**由相同性质的**数据元素**组成，数据元素由**数据项**组成
	三要素：逻辑结构(独立)，存储结构，运算
	[1.1.3 : ALL]
- 时间复杂度
	最坏情况作为评价标准
	迭代: 统计循环主题频度之和，设某条语句执行次数为t方程求解嵌套循环由内向外 
	递归: 列出T(n)递推式
	[1.2.3 : ALL]
- 空间复杂度 
# 线性表
- 顺序表
	[2.2.3 : ALL]
- 单链表
	[2.3.7 : 6, 8, 9, 10, 11, 13, 19, 33, 36]
- 双链表
	[2.3.7 : 15, 16, 17, 18, 20, 35]
- 循环链表
	[2.3.7 : 21, 22, 25, 26, 27, 32, 34]
# 栈-队列-数组
- 栈
	- **基本性质与运算**
		共享栈(降低上溢可能),下溢～空读,上溢～满写
		[3.1.4 : 1, 2, 3, 4, 6, 8, 9, 10, 11, 24, 25, 31]
		[3.3.6 : 1, 17, 11]
	- **出栈入栈模拟**
		[3.1.4 : 7, 12, 16, 26, 30, 27]
	- **确定某一个出栈元素**
		[3.1.4 : 17, 18, 20, 21, 22, 29]
	- **某子列为前缀的出栈序列**
		[3.1.4 : 15, 28]
	- **非法出栈序列**
	 某一个元素出栈时，在其之前入栈的元素若未出栈，则将来必定逆序输出，基于此规律可以快速排出非法序列; 该规律也可以用于解决前缀出栈序列和某一个出栈元素
		[3.1.4 : 14, 19]
	- 表达式-递归-括号匹配
		中缀转后缀括号处理：
		 ***操作数直接入结果，操作符优先级高于栈顶则入栈，否则出栈，直至栈空或遇到优先级更低的算符 或 ( 最后在入栈***
		 括号也视作操作符
		 **右括号优先级最低**
		 **左括号优先级入栈前最高，入栈后最低**
		 [3.3.6 : 2, 4, 13, 14, 19, 18 ; 5, 6, 7, 8, 15 ; 20]
	- **出栈序列数**
		[3.1.4 : 13, 23]
$$
卡特兰数 \frac{1}{n+1} C\genfrac{}{}{0pt}{}{n}{2n}
$$
		
- 队列
	- 基本特性与运算
		[3.2.5 : 1, 2, 3, 11, 12, 13, 14, 15, 16, 17]
		[3.3.6 : 3, 10, 12]
	- 出队序列
		[3.2.5 : 4, 18, 23, 24 ; 6, 8, 9, 10 (空满判断)] 
		[3.3.6 : 16 多队列出入队]
	- 循环队列
		[3.2.5 : 5, 7, 21]
		 front指向队首，rear指向队尾下一位
		 front指向队首下一位，rear指向队尾
		 二者在判空满运算是等价的
		 **空:rear\==front**
		 **满:(rear+1)%n\==front**
		 **长度:(rear-front+n)%n
	- 双端队列
		[3.2.5 : 19, 20, 22]
- 特殊矩阵
	- 数组
		[3.4.5 : 4, 5, 15]
	- 对称矩阵
		[3.4.5 : 2, 3, 13, 14]
	- 三对角矩阵
		[3.4.5 : 6, 11]
	- 三角矩阵
		[3.4.5 : 7, 8]
	- 稀疏矩阵
		三元组/十字链表
		[3.4.5 : 9, 12, 16]
# 树
- 结点数~度数~边数~高度~种数
	对于求h的最小值，通过建立前h-1层和前h层与n的不等式求解
	结点数 = 边数+1 = 度和+1 ; 森林中的每一棵树结点数比边数多1
$$
\begin{bmatrix}
nn_n+...+2n_2+n_1=M \\
n_n+...n_0=M+1
\end{bmatrix}
$$
	[5.1.3 : 2, 7, 8, 9, 10, 4, 5, 6]
	[5.2.3 : 23, 19, 29 ; 4, 5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 22, 24, 25, 26, 27 (二叉树) ; 6 (种数)]
- 完全二叉树与满二叉树
	[5.2.3 : 20, 21]
- 二叉树存储
	[5.2.3 : 28, 30]
- 二叉树遍历
	- 考察基本性质(手算遍历序列;判断结点间在不同遍历下的次序) 
		 1. 前中后遍历叶子结点次序相同
		    [5.3.3 : 1, 2, 3, 4, 5, 6, 7, 8, 11, 12, 19, 32, 39, 41, 42, 43]
    - 根据2个遍历序列还原二叉树 
		 1. 必须配合中序遍历才能唯一确定
		 2. 前序和后序结合可以确定祖先关系
			[5.3.3 : 9, 10, 13, 14, 16, 17, 18, 34, 35,]
	- 某2个遍历序列相同确定二叉树特征 
			[5.3.3 : 15, 30, 31, 40, ]  
	- 遍历特性应用 
			[5.3.3 : 20, 21]
- 线索二叉树(叶子节点放线索)
	- 考察基本性质(线索数，前后线索树的缺点-*前线索不好求前驱,后线索不好求后继，得用三叉链*-)
			[5.3.3 : 22 ~ 28, 33, 36, 37,]
- 树-森林-二叉树
	- 左孩子右兄弟 ; 遍历关系(树林二，先先先，后中中)
		[5.4.4 : ALL ]
- 并查集
	双亲表示法，根双亲域为负数，相反数是以此为根的树结点数
	小树并入大树
	路径压缩(find过程x到根前1个直接挂到根下)
	[5.5.3 : 10~13]
- 霍夫曼树
	**对于霍夫曼树的WPL还等于分支节点权值和**
	**加权平均长度=WPL/叶子结点权值和**
	霍夫曼树是正则二叉树，无度为1的结点
	[5.5.3 : 1~9, 14~23]
$$
	WPL=\sum_i^nw_il_i
$$
# 图
# 查找
# 排序